{"meta":{"title":"Lemony Blog","subtitle":"凝萌的小窝","description":null,"author":"LemonyNingmeng","url":"https://NingmengLemon.github.io","root":"/"},"pages":[{"title":"","date":"2023-12-28T04:32:15.894Z","updated":"2023-12-28T04:32:15.894Z","comments":true,"path":"custom.css","permalink":"https://ningmenglemon.github.io/custom.css","excerpt":"","text":":root { --gutter: 25px; --radius: 13px; --color-primary: #66ccff; --color2: #35c9bb; --color3: #ffb900; --color4: #33d57a; --color5: #00dbff; --color6: #1a98ff; --color7: #9090ff; --color-primary-bg: rgba(102, 204, 255, 0.15); --color2-bg: rgba(53, 201, 187, 0.15); --color3-bg: rgba(255,185,0,0.15); --color4-bg: rgba(51,213,122,0.15); --color5-bg: rgba(0,219,255,0.15); --color6-bg: rgba(26,152,255,0.15); --color7-bg: rgba(144,144,255,0.15); --color-shadow: rgba(161, 177, 204, 0.4); }"},{"title":"文章归档","date":"2023-12-27T13:29:47.459Z","updated":"2023-12-27T13:28:23.464Z","comments":true,"path":"archive.html","permalink":"https://ningmenglemon.github.io/archive.html","excerpt":"","text":""},{"title":"朋友们","date":"2023-12-28T07:30:03.571Z","updated":"2023-12-28T07:30:03.571Z","comments":true,"path":"friends.html","permalink":"https://ningmenglemon.github.io/friends.html","excerpt":"","text":"朋友们"},{"title":"关于","date":"2023-12-27T16:00:00.000Z","updated":"2023-12-28T06:47:48.574Z","comments":true,"path":"about.html","permalink":"https://ningmenglemon.github.io/about.html","excerpt":"","text":"18 岁，事个沙贝 Nice to meet you ( •̀ ω •́ )✧ 咱目前就读于杭州电子科技高等专科学校大学 是数学苦手、编程苦手和社交苦手 头像来源"}],"posts":[{"title":"尝试详细介绍一下我的 BiliTools","slug":"Try-to-introduce-my-BiliTools","date":"2023-12-29T07:36:00.000Z","updated":"2023-12-30T18:13:49.275Z","comments":true,"path":"2023/12/29/Try-to-introduce-my-BiliTools/","permalink":"https://ningmenglemon.github.io/2023/12/29/Try-to-introduce-my-BiliTools/","excerpt":"","text":"想要介绍一下陪了自己两年多的项目 , 顺便练一下 markdown 语法 阅前提示: 以下内容的措辞可能令人费解, 因为咱在表达方面并没有什么天赋 以下内容不一定正确, 如果有错误欢迎提出w IntroBiliTools 是我在 2021 年 5 月左右使用 Python 编写的一个用于下载 B 站的各种资源的程序 关于版本号因为有前身在, 所以版本号直接从 2 开始又因为咱的脑子可能有点抽风, 版本号目前都是 v.2.0.0_Dev{实际更新版本数} 这个样子w目前更新到了 Dev17 的说, 以下内容都是适用于该版本的 关于前身前身是由我编写的 BiliDownloader, 其实就是一个 you-get 的 GUI 而已附加了一点针对 B 站的功能, 比如弹幕下载和过滤, 版本号为 1 史山注意首先最初在写这个程序的时候我还是个若至, 像各种语言规范什么的都不知道 你可以在程序中见到: 随处可见的超长单行 刁钻古怪的调用链 (几乎)没有类型标注 稀少的注释与日志 一些不知道在干什么但是删掉就会出 Bug 的代码 各种若至的代码逻辑 各种花里胡哨但又一堆 Bug 的功能 然后到现在我稍微懂了那么一点语言规范, 但是先前拉的史已经不好收拾了 有的时候甚至都不想再继续写, 想 remake 一个新程序出来了 这个程序伴随着我的进步, 我的程序水平也在逐渐提升（吗？） 所以还是蛮有纪念意义的, 对吧 感谢Bilibili-API-collect danmaku2ass Quick Overview文件结构截至 Dev17 的文件结构如下 12345678910111213141516171819202122232425262728293031BiliTools├─ bilitools.py # 主程序├─ basic_window.py # 提供了(几乎)所有窗口的基类├─ bezier_curve.py # (未使用)用于画贝塞尔曲线的一些基本操作├─ configuration.py # 一些与配置相关的数据与操作├─ custom_widgets.py # 一些自定义的 tk 组件├─ danmaku2ass.py # 修改过的 danmaku2ass├─ ffdriver.py # 用于调用 ffmpeg 的操作├─ imglib.py # 图标们 (以 base64 方式编码的 png)├─ textlib.py # Tips 和 About 文本├─ videoshot_handler.py # 提供了用于处理视频快照的一个类└─ biliapis # 封装了一些 B 站的 API, 大多取自 bilibili-api-collect ├─ __init__.py # 用于统领起这个 API 库, 定义了一些杂七杂八的操作 ├─ requester.py # 用于请求的模块 ├─ error.py # 定义了错误类 ├─ bilicodes.py # 各种常用的标识码 ├─ wbi.py # WBI 鉴权 ├─ article.py # 专栏相关 ├─ audio.py # 音频相关 ├─ comment.py # 评论相关 ├─ danmaku.py # 弹幕相关 ├─ dynamic.py # 动态相关 ├─ live.py # 直播相关 ├─ login.py # 登录相关 ├─ manga.py # 漫画相关 ├─ media.py # 影视与番剧相关 ├─ stream.py # 媒体流相关 ├─ subtitle.py # 字幕相关 ├─ user.py # 用户相关 ├─ video.py # 视频相关 └─ other.py # 其他 API 依赖12345678tkinter # GUI 库, Python 应该会自带pillow # 用于图像处理qrcode # 用于生成二维码beautifulsoup4 # 用于处理 HTML 和 XMLbrotli # 用于解压数据lxml # bs4 的依赖colorama # 用于控制台着色pycryptodome # 用于计算 CorrespondPath ffmpeg - 通过管道进行调用, 安装即可 Go ♂ Deeper各个类间的继承关系点击展开 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647object├─ DownloadManager├─ Window│ ├─ MainWindow│ ├─ BatchWindow│ ├─ InputWindow│ ├─ ConfigWindow│ ├─ AudioWindow│ ├─ CommonVideoWindow│ ├─ CollectWindow│ ├─ LoginWindow│ ├─ PbpShower│ ├─ PartsChooser│ ├─ BlackroomWindow│ ├─ BangumiWindow│ ├─ MangaViewer_Rolling (未完工)│ ├─ MangaViewer_PageTurning (未完工)│ ├─ SearchWindow│ ├─ PlotShower│ ├─ VideoShotViewer│ ├─ ArticleWindow (未完工)│ ├─ ToviewWindow (未完工)│ └─ Thread_with_gui├─ ToolTip├─ _CustomMsgbox└─ VideoShotHandlertk.Frame└─ VerticalScrolledFrame ├─ _CommonVideoSearchShower └─ _MediaSearchShowerttk.Button└─ ImageButtontk.Label└─ ImageLabeltk.Toplevel└─ _TipWindowException└─ BiliErrorthreading.Thread└─ _DownloadThread 多线程的处理就像其他基于 tk 的应用程序一样, 此程序也以主线程为主 为了处理那些耗时的任务, 自然是需要用到子线程的, 但是子线程没办法直接修改 tk 窗口中的对象, 一修改就会导致thread not in mainloop错误 于是我在basic_window.py中的Window基类中定义了一个task_queue成员. 这是一个队列, 子线程可以向其中放入无参的函数对象, 而这些函数对象会被位于主线程中的由Tk.after()驱动的一个自动循环执行的函数listen_task自动取出并在主线程中执行. 此时这个函数是在主线程中被执行的, 就可以直接修改窗口中的对象了. 像这样, 耗时的任务就可以在子线程中执行完毕, 然后把数据装在上述的函数中发送给主线程, 进而由函数填充到窗口中 (填充的过程其实耗时很少) 这个基类的多线程控制部分 1234567891011121314151617181920212223242526272829class Window(object): # 程序中所有常规窗口的父类 def __init__(self,title=&#x27;BiliTools&#x27;,toplevel=False,topmost=False,alpha=1.0,master=None): self.task_queue = queue.Queue() # 此队列用于储存来自子线程的无参函数对象 if toplevel or master: self.window = tk.Toplevel(master=master) else: self.window = tk.Tk() ... self.listen_task() def listen_task(self): if not self.task_queue.empty(): func = self.task_queue.get_nowait() try: func() except Exception as e: logging.error(&#x27;Task Listener Caught an Error: &#x27;+str(e)) #raise traceback_info = traceback.format_exc() # print(traceback_info) else: pass #logging.debug(&quot;Call func: &quot;+str(func)) if self.task_queue.empty(): self.window.after(10,self.listen_task) else: self.window.after(1,self.listen_task) ... ...是被省略的部分 我通过这种方式来进行多线程协调. 听上去还是蛮巧妙的? 但是, 把这个方法写在基类中就意味着, 每个窗口创建时都会附带一个队列和一个反复执行的函数. 我不清楚别人是不是这么做的, 反正我当时就这么写了w.现在我对这个做法其实不是很满意, 因为我认为这可能消耗了额外的资源 , 多少有些强迫症了(当然也可能是因为现在我学会了异步, 然后觉得之前的我很蠢就是了) 网络请求的封装比较让人难绷的是, 我以前把负责网络请求的模块requester直接放在了biliapis模块中, 我现在觉得这个层次结构不算合理.这也就是说, 要想把biliapis模块用到别的项目中, 底下的requester也会被 copy 一份, 而那个别的项目中可能已经有了别的网络请求模块, 就会造成冗余…然后requester中封装的get与post还对返回的流对象做了处理, 把请求过程中创建的req.Request对象嗯塞了进去, 这是为了方便login模块中对 cookies 的操作. 但也进一步导致了可移植性的下降. 搓程序时候的趣事(?) ChatGPT 一开始说用urllib打开的流中会有request这个成员, 但是其实使用 opener 打开的流中并没有, 当时跟 GPT 杠了挺久, 然后 GPT 改口了ww GPT 最终的答复是: 根据你提供的代码，使用opener.open()方法发送请求并获得响应。在这种情况下，response对象是由opener.open()方法返回的，而不是urlopen()函数返回的。Opener对象是urllib.request模块中的一个类，用于发送HTTP请求。opener.open()方法接受一个Request对象作为参数，并返回一个HTTPResponse对象，表示服务器的响应。然而，opener.open()方法返回的HTTPResponse对象可能不会附带request属性。这是因为opener.open()方法是一个高级接口，它隐藏了底层的请求细节，不直接暴露Request对象。 以get方法为例, 它的代码如下 1234567@auto_retry(retry_time)def get(url, headers=fake_headers_get): req = request.Request(url, headers=headers) response = opener.open(req, None, timeout=timeout) response.request = req # 强行塞入 request logging.debug(&#x27;Get: &#x27;+url) return response 我猜你想吐槽... 啊你这个请求怎么没有用with啊这个函数怎么直接就把流对象传回去了啊 emm来看其他部分是怎么用这个函数的: 1234567def get_content_bytes(url, headers=fake_headers_get, update_cookie=True): # 取名有问题, 请自动忽略 content 这个词 with get(url, headers=headers) as response: if cookies and update_cookie: cookies.make_cookies(response, response.request) return read_and_decode_data(response) # 取名也有问题, decode 应该改成 decompress 我其实不是很确定用自动重试装饰器来修饰这个函数是不是正确的选择 总之就是很不满意 (叉腰) 多窗口之间的协作首先需要提醒的是, 下文提到的Window(定义在basic_window.py中)继承自object, tk.Tk或者tk.Toplevel对象则被存放在Window.window处 很令人费解是吧? 我也想问问以前的我为什么要这么写 我一般会在窗口类(一般继承自Window)的__init__()方法的末尾加上self.window.wait_window(self.window)来使外界在执行实例化窗口类的操作时停在这一步, 直到窗口被释放 (self.window.destroy()被执行)官方的模块 tk.messagebox 和 tk.filedialog 中的操作也有类似的逻辑 当时的我在Window类中直接把上面那个”停下”的操作封装成了self.mainloop()这个方法, 极具迷惑性.注意与下文提到的mainloop做区别.越写就越想穿越回去抽自己几个大嘴巴子 对于大部分不需要在打开窗口的同时打开另一个窗口的窗口是这样.至于为什么不用Tk.mainloop()来等待窗口, 是因为我发现如果这样做的话, 关闭窗口时会产生一些莫名其妙的问题按照我的理解, Tk.mainloop()会使整个 tk 的事件循环阻塞主线程; 如果通过Tk.destroy()将其打破, tk 会认为整个程序应该结束了, 但其实没有, 这只是一个窗口关闭了而已 于是我的整个程序里一个Tk.mainloop()都没用过w 而除了下载窗口外的所有子窗口(Toplevel)的父窗口都是主窗口(Tk), 当把主窗口关掉的时候其余窗口就会被自动地关闭.至于下载窗口, 它拥有特殊的内部逻辑, 并没有使用等待窗口这一机制. 下载器的内部逻辑这一部分最初于 2021 年 11 月左右完成 (根据写的日志来看)当时这部分是在自习课上想出来的, 笔记本应该还能找到, 但是放在家里了w 这一部分是线程安全问题的重灾区, 中途尝试修复过一次, 给涉及到多线程操作的几个列表添加了线程锁. 但是漏掉了最核心的用于存储原始数据的列表和另外三个用于存放任务状态的列表我最终发现这个遗留问题的时候已经为时已晚. 各个线程锁在之前尝试修复的时候搅成了一坨, 就连继续往上拉史都做不到了, 哪怕只加一个线程锁都会在莫名其妙的地方锁死当然如果花时间的话其实还是可以修复的, 需要把之前修的地方推掉重来 显示机制并不是通过修改窗口属性将构建好的窗口显示或隐藏, 而是到了需要显示的时候才开始构建 当 用于接受下载任务的task_receiver()被调用 且 这个函数运行于主线程中 时, show()方法会被自动调用show()方法会执行构建 GUI 的代码, 而hide()方法则会直接销毁整个窗口由于涉及到 GUI 操作, 上述两个方法都必须在主线程中运行 窗口中显示的的任务信息存储在table_display_list这个多维列表中, 每次刷新显示的信息时auto_refresh_table这个方法会将它的内容展示到 GUI 中 auto_refresh_table也是借助Tk.after()来进行自动循环的 下载器刷新 GUI 的流程: 刷新任务列表 如果任务数没有变动, 那么直接修改对应项的值 如果任务数有变动: 先记录哪些项被选中了 然后删除列表框中的所有项 将新的信息填充进去 复现先前选中的项 更新统计信息 准备下一次自动刷新 数据存储与任务管理最核心的内容是data_objs这个成员, 它存储着传入task_receiver的原始数据下载的各个步骤都会读取或修改它 有三个索引列表与它相关 failed_indexes running_indexes done_indexes 存放的内容是任务对应的数据在data_objs中的索引也是在table_display_list中的索引 我认为下载器中的最关键的一个量就是这个索引在特化的任务函数中第一个显式参数就是index, 说的就是这个索引 感觉逼逼叨叨这么多还不如放张图, 等我… flowchart TB F[/下载管理器实例化/] -- 启动 --> auto_thread_starter subgraph auto_thread_starter direction TB b{检查 task_queue} b -- 有任务 --> c[将任务取出, 作为子线程开始运行] b -- 无任务 --> b c --> b end c -- 启动 --> task_itself subgraph task_itself direction TB g[将参数中的 index 放入 running_indexes] g --> h[任务计数器+1] h --> i[进行任务内容] i --> j[将 index 从 running_indexes 中移除] j --> k{任务是否成功} k -- 是 --> l[将 index 放入 done_indexes] k -- 否 --> m[将 index 放入 failed_indexes] l --> n(任务计数器-1) m --> n end 如果要添加任务, 则遵循下面的流程: flowchart TB direction TB A[/添加任务/] --> B[获取到下载所需的数据] B --> C[将任务数据放入 data_objs] C --> D[ 将对应的任务函数和任务在 data_objs 中的索引和数据包装成 lambda 然后放入 task_queue ] D --> E[ 在 table_display_list 中创建位置 任务在两个列表中的索引保持一致 ] 进度的保存与读取保存程序会遍历整个data_objs, 从中筛选出还没有成功的任务组成一个列表然后将这个列表作为一个临时字典的objs键对应的值table_display_list中对应的项也会被组成列表, 作为这个临时字典的displaylist键对应的值最后程序会将这个字典保存为 json 文件 上述操作被封装为了save_progress这个方法这个方法在每次有任务开始或结束的时候都会被调用 读取首先程序会读取保存的 json 文件, 然后遍历其中的objs列表, 按照与task_receiver中类似的方法逐个添加任务在这个过程中, 除了任务状态文本会被改成待处理外, 其余内容将会与保存前保持一致 上述操作被封装为了load_progress这个方法这个方法在程序启动的时候经过用户确认后会被调用 &gt;&gt; To be continued… &lt;&lt;","categories":[{"name":"Program","slug":"Program","permalink":"https://ningmenglemon.github.io/categories/Program/"}],"tags":[{"name":"Bilibili","slug":"Bilibili","permalink":"https://ningmenglemon.github.io/tags/Bilibili/"},{"name":"Python","slug":"Python","permalink":"https://ningmenglemon.github.io/tags/Python/"},{"name":"Tkinter","slug":"Tkinter","permalink":"https://ningmenglemon.github.io/tags/Tkinter/"}]},{"title":"Just a test","slug":"Just-a-test","date":"2023-12-27T11:11:44.000Z","updated":"2023-12-29T07:32:33.990Z","comments":true,"path":"2023/12/27/Just-a-test/","permalink":"https://ningmenglemon.github.io/2023/12/27/Just-a-test/","excerpt":"","text":"Hello bro, this is just a test page. If set properly, a sticker will be displayed below.","categories":[{"name":"Test","slug":"Test","permalink":"https://ningmenglemon.github.io/categories/Test/"}],"tags":[{"name":"Test","slug":"Test","permalink":"https://ningmenglemon.github.io/tags/Test/"},{"name":"Cheshire Cat","slug":"Cheshire-Cat","permalink":"https://ningmenglemon.github.io/tags/Cheshire-Cat/"}]}],"categories":[{"name":"Program","slug":"Program","permalink":"https://ningmenglemon.github.io/categories/Program/"},{"name":"Test","slug":"Test","permalink":"https://ningmenglemon.github.io/categories/Test/"}],"tags":[{"name":"Bilibili","slug":"Bilibili","permalink":"https://ningmenglemon.github.io/tags/Bilibili/"},{"name":"Python","slug":"Python","permalink":"https://ningmenglemon.github.io/tags/Python/"},{"name":"Tkinter","slug":"Tkinter","permalink":"https://ningmenglemon.github.io/tags/Tkinter/"},{"name":"Test","slug":"Test","permalink":"https://ningmenglemon.github.io/tags/Test/"},{"name":"Cheshire Cat","slug":"Cheshire-Cat","permalink":"https://ningmenglemon.github.io/tags/Cheshire-Cat/"}]}